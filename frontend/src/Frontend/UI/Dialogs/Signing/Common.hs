{-# LANGUAGE CPP #-}
{-# LANGUAGE RecursiveDo #-}
{-# LANGUAGE TupleSections #-}

module Frontend.UI.Dialogs.Signing.Common
  ( uiSignatures
  , uiSigningInput
  ) where

import           Control.Error hiding (bool, note)
import           Control.Lens ((%~))
import           Control.Monad.State.Strict
import           Data.Aeson
import qualified Data.ByteString.Lazy as LB
import           Data.Default (Default (..))
import qualified Data.IntMap as IntMap
import qualified Data.Map as Map
import           Data.String
import           Data.Text (Text)
import qualified Data.Text as T
import qualified Data.Text.Encoding as T
import qualified Data.Text.Lazy as LT

#if !defined(ghcjs_HOST_OS)
import qualified Codec.QRCode as QR
import qualified Codec.QRCode.JuicyPixels as QR
#endif
import qualified Data.YAML.Aeson as Y

import           Pact.Types.SigData
import           Pact.Types.ChainMeta
import           Pact.Types.Command
import qualified Pact.Types.Hash as Pact
import           Pact.Types.Scheme
import qualified Pact.Types.Term as Pact
import           Reflex.Dom.Core

import           Common.Wallet
import           Frontend.Crypto.Class
import           Frontend.Crypto.Ed25519
import           Frontend.Crypto.Signature
import           Frontend.Foundation
import           Frontend.Network
import           Frontend.UI.TabBar
import           Frontend.UI.Widgets
import           Frontend.UI.Widgets.Helpers
import           Frontend.UI.Form.Common

uiSignatures
  :: ( MonadWidget t m
     , HasCrypto key m
     )
  => (KeyStorage key)
  -> Payload PublicMeta Text
  -> [PublicKey]
  -> m (Dynamic t (Command Text))
uiSignatures keyStorage payload pubKeys = do
  cmd <- buildCmdWithPayload payload []
  -- Incomplete pattern match should be fine here because all the possible
  -- commands are statically generated by Chainweaver.
  let Right sd = commandToSigData cmd
  let hash = Pact.toUntypedHash $ _sigDataHash sd
  _ <- divClass "group" $ do
    uiPreviewItem "Request Key" $ el "code" $ text (Pact.hashToText hash)

  let mkKeyTuple (KeyPair pub priv) = (pub, priv)
  let cwKeyMap = Map.fromList . map (mkKeyTuple . _key_pair) . IntMap.elems $ keyStorage
      sigsNeeded = length $ filter (\pubKey -> not $ isJust $ join $ Map.lookup pubKey cwKeyMap) pubKeys

  dialogSectionHeading mempty $ if sigsNeeded > 0 then "External Signatures" else "No external signatures needed"

  let sig pubKey = do
        let pubKeyText = keyToText pubKey
        case Map.lookup pubKey cwKeyMap of
          Just (Just priv) -> do
            s <- cryptoSign (Pact.unHash hash) priv
            pb <- getPostBuild
            let ju = (fromString $ T.unpack pubKeyText, Just $ UserSig $ keyToText s)
            holdDyn ju (ju <$ pb)
          _ -> do
            el "div" $ text pubKeyText
            uiSigningInput hash pubKey
      wrapper sigSection = if sigsNeeded > 0
        then divClass "group signing-ui-signers" sigSection
        else sigSection
  ddsigs <- wrapper $ do
    forM pubKeys $ \pubKey -> do
      sig pubKey

  let sigs = distributeListOverDyn ddsigs
  let addSigs ss = sd { _sigDataSigs = ss }
  let signedCmd = addSigs <$> sigs

  rec
    keysetOpen <- toggle False clk
    (clk,(_,_k)) <- controlledAccordionItem keysetOpen mempty
      (accordionHeaderBtn "Advanced Details and Signing Data") $ do
        viewSigData signedCmd

  return (either error id . sigDataToCommand <$> signedCmd)

data SigDataViewMode
  = SigDataViewMode_Yaml
  | SigDataViewMode_Json
  | SigDataViewMode_HashQR
  | SigDataViewMode_FullQR
  deriving (Eq,Ord,Show,Read,Enum,Bounded)

showSigDataViewModeTabName :: SigDataViewMode -> Text
showSigDataViewModeTabName = \case
  SigDataViewMode_Json -> "JSON"
  SigDataViewMode_Yaml -> "YAML"
  SigDataViewMode_HashQR -> "Hash QR Code"
  SigDataViewMode_FullQR -> "Full Tx QR Code"

viewSigData
  :: (DomBuilder t m, MonadHold t m, PostBuild t m, MonadFix m)
  => Dynamic t (SigData Text)
  -> m ()
viewSigData signedCmd = do
    divClass "tabset" $ mdo
      curSelection <- holdDyn SigDataViewMode_Json onTabClick
      (TabBar onTabClick) <- makeTabBar $ TabBarCfg
        { _tabBarCfg_tabs = [minBound .. maxBound]
        , _tabBarCfg_mkLabel = const $ text . showSigDataViewModeTabName
        , _tabBarCfg_selectedTab = Just <$> curSelection
        , _tabBarCfg_classes = mempty
        , _tabBarCfg_type = TabBarType_Primary
        }

      tabPane mempty curSelection SigDataViewMode_Yaml $ do
        let preview = T.decodeUtf8 . Y.encode1Strict <$> signedCmd
        iv <- sample (current preview)
        uiTextAreaElement $ def
          & textAreaElementConfig_initialValue .~ iv
          & initialAttributes %~ (<> "disabled" =: "" <> "style" =: "width: 100%; height: 18em;")
          & textAreaElementConfig_setValue .~ updated preview

      tabPane mempty curSelection SigDataViewMode_Json $ do
        let preview = T.decodeUtf8 . LB.toStrict . encode . toJSON <$> signedCmd
        iv <- sample (current preview)
        uiTextAreaElement $ def
          & textAreaElementConfig_initialValue .~ iv
          & initialAttributes %~ (<> "disabled" =: "" <> "style" =: "width: 100%; height: 18em;")
          & textAreaElementConfig_setValue .~ updated preview

#if !defined(ghcjs_HOST_OS)
      tabPane mempty curSelection SigDataViewMode_HashQR $ do
        let hashText = Pact.hashToText . Pact.toUntypedHash . _sigDataHash <$> signedCmd
            qrImage = QR.encodeText (QR.defaultQRCodeOptions QR.L) QR.Iso8859_1OrUtf8WithECI <$> hashText
            img = maybe "Error creating QR code" (QR.toPngDataUrlT 4 6) <$> qrImage
        el "div" $ text $ T.unwords
          [ "This QR code contains only the request key."
          , "It doesn't give any transaction information, so some wallets may not accept it."
          , "This is useful when you are signing your own transactions and don't want to transmit as much data."
          ]
        el "br" blank
        elDynAttr "img" (("src" =:) . LT.toStrict <$> img) blank
      tabPane mempty curSelection SigDataViewMode_FullQR $ do
        let yamlText = T.decodeUtf8 . Y.encode1Strict <$> signedCmd
            qrImage = QR.encodeText (QR.defaultQRCodeOptions QR.L) QR.Iso8859_1OrUtf8WithECI <$> yamlText
            img = maybe "Error creating QR code" (QR.toPngDataUrlT 4 4) <$> qrImage
        elDynAttr "img" (("src" =:) . LT.toStrict <$> img) blank
#else
      let notAvailMsg = el "ul" $ text "This feature is not currently available in the browser"
      tabPane mempty curSelection SigDataViewMode_HashQR notAvailMsg
      tabPane mempty curSelection SigDataViewMode_FullQR notAvailMsg
#endif

      pure ()

uiSigningInput
  :: ( MonadWidget t m
     , HasCrypto key m
     )
  => Pact.Hash
  -> PublicKey
  -> m (Dynamic t (PublicKeyHex, Maybe UserSig))
uiSigningInput hash pubKey = do
  let
    inp cfg = do
      ie <- mkLabeledInput False mempty uiInputElement cfg

      sigDyn <- networkHold (pure $ Left "") (checkSigOrKey hash pubKey <$> updated (value ie))
      pure (ie
           , ( sigDyn
             , updated sigDyn
             )
           )

    inputCfg = def
      & initialAttributes .~ ("placeholder" =: "Signature or Private Key" <>
                              "class" =: "signature-input" <>
                              "type" =: "password")
                              --"rows" =: "2")

    -- Don't show the error popover if nothing has been entered
    -- See checkSigOrKey for where this is generated.
    mkErr e = if T.null e
                then PopoverState_Disabled
                else PopoverState_Error e -- "Must be a signature or private key"
    showPopover (_, (_, onInput)) = pure $
      either mkErr (const PopoverState_Disabled) <$> onInput

  (_inputE, (dE, _onE)) <- uiInputWithPopover
    inp
    (_inputElement_raw . fst)
    showPopover
    inputCfg

  pure $ (PublicKeyHex $ keyToText pubKey,) . hush <$> dE

checkSigOrKey
  :: forall key m.
     ( MonadJSM m
     , HasCrypto key m
     )
  => Pact.Hash
  -> PublicKey
  -> Text
  -> m (Either Text UserSig)
checkSigOrKey hash pubKey userInput = do
    let hashBytes = Pact.unHash hash
    let tryAsKey t = do
          -- Expects input to be 64 hex characters
          case textToKey t of
            Nothing -> do
              pure $ Left "Couldn't parse as key"
            Just (PrivateKey privKey) -> do
              let pactKey = PactKey ED25519 pubKey privKey
              cryptoSignWithPactKeyEither hashBytes pactKey >>= \case
                Left _ -> pure $ Left $ "Wrong key"
                Right sig -> do
                  valid <- cryptoVerify hashBytes sig pubKey
                  if valid
                    then pure $ Right sig
                    else pure $ Left $ "Key does not generate a valid signature"
        tryAsSig t = do
          case parseSignature t of
            Left _ -> do
              pure $ Left $ "Error parsing signature"
            Right sig -> do
              --pure $ Right sig
              valid <- cryptoVerify hashBytes sig pubKey
              pure $ if valid
                then Right sig
                else Left "Signature not valid"

    res <- case T.length userInput of
      128 -> if T.drop 64 userInput == keyToText pubKey
               then tryAsKey $ T.take 64 userInput
               else tryAsSig userInput
      64 -> tryAsKey userInput

      -- This is kind of a janky way to prevent the error popup from displaying
      -- when the form first opens but it's good enough for now.
      0 -> pure $ Left ""
      _ -> pure $ Left genericErr
    pure $ UserSig . keyToText <$> res
  where
    genericErr = "Must specify a key or signature"
